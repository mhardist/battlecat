# i1: Listen to Tutorial — Subagent-Driven Development Execution Plan

## How to One-Shot Execute This Plan

Copy-paste this prompt into a fresh Claude Code session to execute the entire plan:

---

### One-Shot Execution Prompt

```
Use the subagent-driven-development skill to execute the plan in /Users/developer-sandbox/Desktop/Development/miki/playground/i1.md

Branch: bkirsch-listen-build (already checked out)
Working directory: /Users/developer-sandbox/Desktop/Development/miki/playground/battlecat

Execute all 7 tasks sequentially. For each task:
1. Dispatch a fresh implementer subagent with the full task text and context
2. After implementation, dispatch a spec reviewer subagent
3. After spec approval, dispatch a code quality reviewer subagent
4. Mark task complete only when both reviews pass

Commit after each task passes both reviews.
```

---

## Task 1: Test Infrastructure Setup

### What to do
Install Vitest and testing libraries. Create Vitest config.

### Files to modify
- `battlecat/package.json`
- NEW: `battlecat/vitest.config.ts`

### Detailed instructions

**1a. Add devDependencies to `battlecat/package.json`:**
```json
"vitest": "^3.0.0",
"@testing-library/react": "^16.0.0",
"@testing-library/jest-dom": "^6.0.0",
"@testing-library/user-event": "^14.0.0",
"jsdom": "^25.0.0"
```

**1b. Add test script to `battlecat/package.json`:**
```json
"test": "vitest run"
```

**1c. Create `battlecat/vitest.config.ts`:**
```ts
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: [],
  },
});
```

**1d. Run:**
```bash
cd battlecat && npm install
npx vitest --version
```

### Acceptance criteria
- `npx vitest --version` succeeds
- `npm test` runs without config errors (may report "no tests found" which is fine)

---

## Task 2: Foundation — Config/Types/Schema

### What to do
Add `audio_url` field across the codebase. No tests needed — these are config/type changes.

### Files to modify
- `battlecat/src/types/index.ts`
- `battlecat/src/data/seed-tutorials.ts`
- `battlecat/src/db/schema.sql`
- NEW: `battlecat/src/db/migrations/001_add_audio_url.sql`
- `battlecat/.env.example`

### Detailed instructions

**2a. `battlecat/src/types/index.ts` — Add to Tutorial interface after line 63 (`image_url: string | null;`):**
```ts
audio_url: string | null;
```

**2b. `battlecat/src/data/seed-tutorials.ts` — Add `audio_url: null` to every seed tutorial object.**
There are 10 seed tutorials. Each one needs `audio_url: null` added after the `image_url` field. Example for seed-01:
```ts
image_url: null,
audio_url: null,
```

All 10 tutorials need this field added:
- seed-01 (line ~47)
- seed-02 (line ~98)
- seed-03 (line ~149)
- seed-04 (line ~209)
- seed-05 (line ~269)
- seed-06 (line ~325)
- seed-07 (line ~389)
- seed-08 (line ~484)
- seed-09 (line ~598)
- seed-10 (line ~713)

**2c. `battlecat/src/db/schema.sql` — Add after `image_url text,` (line 32):**
```sql
audio_url text,
```

**2d. Create `battlecat/src/db/migrations/001_add_audio_url.sql`:**
```sql
ALTER TABLE tutorials ADD COLUMN IF NOT EXISTS audio_url text;
```

**2e. `battlecat/.env.example` — Add at the end:**
```
# Audio generation
AUDIO_ENABLED=true
TOGETHER_API_KEY=your-together-key
```

**2f. Verify:**
```bash
cd battlecat && npx tsc --noEmit
```

### Acceptance criteria
- `npx tsc --noEmit` passes with zero errors
- All 10 seed tutorials have `audio_url: null`
- Tutorial interface includes `audio_url: string | null`

---

## Task 3: Backend TDD — generate-audio.ts

### What to do
Create `generate-audio.ts` and its test file using strict TDD (Red-Green-Refactor). This is the largest task.

### Files to create
- NEW: `battlecat/src/lib/__tests__/generate-audio.test.ts`
- NEW: `battlecat/src/lib/generate-audio.ts`

### Detailed instructions

Follow these TDD cycles exactly. For each cycle: write the test FIRST, verify it fails, then write minimal production code to make it pass.

#### Function 1: `stripMarkdownToScript`

**Cycle 1 — Headers:**
```ts
// Test:
test('removes markdown headers', () => {
  expect(stripMarkdownToScript('## Hello World')).toBe('Hello World');
  expect(stripMarkdownToScript('### Sub heading')).toBe('Sub heading');
});
```
Create `generate-audio.ts`, export `stripMarkdownToScript`. Minimal header-stripping regex.

**Cycle 2 — Code blocks:**
```ts
test('removes fenced code blocks', () => {
  const input = 'Before\n```js\nconst x = 1;\n```\nAfter';
  expect(stripMarkdownToScript(input)).toBe('Before\nAfter');
});

test('removes inline code', () => {
  expect(stripMarkdownToScript('Use `npm install` to install')).toBe('Use npm install to install');
});
```

**Cycle 3 — Links, images, URLs:**
```ts
test('converts links to text only', () => {
  expect(stripMarkdownToScript('[Click here](https://example.com)')).toBe('Click here');
});

test('removes images', () => {
  expect(stripMarkdownToScript('![alt text](image.png)')).toBe('');
});

test('removes bare URLs', () => {
  expect(stripMarkdownToScript('Visit https://example.com/path for more'))
    .toBe('Visit for more');
});
```

**Cycle 4 — Bold, italic, blockquotes, lists, rules:**
```ts
test('removes bold and italic markers', () => {
  expect(stripMarkdownToScript('This is **bold** and *italic*')).toBe('This is bold and italic');
});

test('removes blockquote markers', () => {
  expect(stripMarkdownToScript('> This is a quote')).toBe('This is a quote');
});

test('removes list markers', () => {
  expect(stripMarkdownToScript('- Item one\n* Item two\n1. Item three'))
    .toBe('Item one\nItem two\nItem three');
});

test('removes horizontal rules', () => {
  expect(stripMarkdownToScript('Above\n---\nBelow')).toBe('Above\nBelow');
});
```

**Cycle 5 — HTML entities, tags, tables:**
```ts
test('decodes HTML entities', () => {
  expect(stripMarkdownToScript('Tom &amp; Jerry &lt;3')).toBe('Tom & Jerry <3');
});

test('strips inline HTML tags', () => {
  expect(stripMarkdownToScript('Hello <br> world <strong>bold</strong>'))
    .toBe('Hello world bold');
});

test('removes markdown tables entirely', () => {
  const table = '| Col1 | Col2 |\n|------|------|\n| a | b |';
  expect(stripMarkdownToScript(table).trim()).toBe('');
});
```

**Cycle 6 — Whitespace normalization:**
```ts
test('collapses multiple newlines to single newline', () => {
  expect(stripMarkdownToScript('Line 1\n\n\n\nLine 2')).toBe('Line 1\nLine 2');
});
```

**Cycle 7 — Real tutorial body regression:**
```ts
test('processes a real seed tutorial body correctly', () => {
  const body = `## Getting Started with AI\n\nAI is **transforming** everything...`;
  const result = stripMarkdownToScript(body);
  expect(result).not.toContain('##');
  expect(result).not.toContain('**');
  expect(result).toContain('Getting Started with AI');
  expect(result).toContain('AI is transforming everything');
});
```

**After Cycle 7: REFACTOR** — Review the accumulated regex pipeline. Ensure ordering is correct (fenced blocks before inline code, images before links). Clean up any duplication.

#### Function 2: `chunkText`

**Cycle 8 — Basic sentence splitting:**
```ts
test('splits text at sentence boundaries under maxChars', () => {
  const text = 'First sentence. Second sentence. Third sentence.';
  const chunks = chunkText(text, 30);
  expect(chunks.length).toBeGreaterThan(1);
  chunks.forEach(chunk => expect(chunk.length).toBeLessThanOrEqual(30));
});

test('keeps sentences together when they fit', () => {
  const text = 'Short. Also short.';
  const chunks = chunkText(text, 1900);
  expect(chunks).toHaveLength(1);
  expect(chunks[0]).toBe('Short. Also short.');
});
```

**Cycle 9 — Long sentence fallback:**
```ts
test('splits single sentence exceeding maxChars at word boundary', () => {
  const longSentence = 'word '.repeat(400); // ~2000 chars
  const chunks = chunkText(longSentence.trim(), 1900);
  expect(chunks.length).toBeGreaterThan(1);
  chunks.forEach(chunk => expect(chunk.length).toBeLessThanOrEqual(1900));
});
```

**Cycle 10 — Edge cases:**
```ts
test('returns empty array for empty string', () => {
  expect(chunkText('')).toEqual([]);
});

test('returns empty array for very short text (under 50 chars)', () => {
  expect(chunkText('Hi')).toEqual([]);
});
```

#### Function 3: `generateTutorialAudio`

**Cycle 11 — Kill switch:**
```ts
test('returns null when AUDIO_ENABLED is not "true"', async () => {
  process.env.AUDIO_ENABLED = 'false';
  const result = await generateTutorialAudio('Some body text', 'test-slug');
  expect(result).toBeNull();
});
```

**Cycle 12 — Missing API key:**
```ts
test('returns null when DEEPGRAM_API_KEY is not set', async () => {
  process.env.AUDIO_ENABLED = 'true';
  delete process.env.DEEPGRAM_API_KEY;
  const result = await generateTutorialAudio('Some body text', 'test-slug');
  expect(result).toBeNull();
});
```

**Cycle 13 — Short text skip:**
```ts
test('returns null when sanitized text is under 50 chars', async () => {
  process.env.AUDIO_ENABLED = 'true';
  process.env.DEEPGRAM_API_KEY = 'test-key';
  const result = await generateTutorialAudio('# Hi', 'test-slug');
  expect(result).toBeNull();
});
```

**Cycle 14 — Full pipeline with mocks:**
```ts
// Mock @deepgram/sdk and @/lib/supabase at top of test file
vi.mock('@deepgram/sdk', () => ({
  createClient: () => ({
    speak: {
      request: vi.fn().mockResolvedValue({
        getStream: () => readableStreamFromBuffer(Buffer.from('fake-mp3')),
      }),
    },
  }),
}));

vi.mock('@/lib/supabase', () => ({
  createServerClient: () => ({
    storage: {
      from: () => ({
        upload: vi.fn().mockResolvedValue({ error: null }),
        getPublicUrl: () => ({ data: { publicUrl: 'https://example.com/audio.mp3' } }),
      }),
    },
  }),
}));

test('generates audio and returns URL on success', async () => {
  process.env.AUDIO_ENABLED = 'true';
  process.env.DEEPGRAM_API_KEY = 'test-key';
  const body = 'A '.repeat(100) + 'long tutorial body with enough content to process.';
  const result = await generateTutorialAudio(body, 'test-slug');
  expect(result).toBe('https://example.com/audio.mp3');
});
```

#### Production code for `generateTutorialAudio`

Follow `generate-image.ts` pattern:
- Never throw — try/catch returns null
- `[audio]` prefix for all console.log/error
- Dynamic import for supabase: `const { createServerClient } = await import("@/lib/supabase")`
- Deepgram TTS: `createClient(apiKey)`, then `client.speak.request({ text }, { model: "aura-2-athena-en", encoding: "mp3", sample_rate: 24000 })`
- For multi-chunk audio: strip MP3 headers from chunks 2+ (skip ID3 tags, find first MPEG frame sync `0xFF 0xFB/0xFF 0xF3/0xFF 0xF2`)
- Concatenate all chunks into single Buffer
- Upload to `audio` bucket: `tutorials/${slug}-${Date.now()}.mp3`
- Return public URL

### Acceptance criteria
- All tests pass with `npm test`
- Every exported function has test coverage
- Mocks only where unavoidable (Deepgram SDK, Supabase client)
- Output pristine (no warnings/errors)

---

## Task 4: Frontend TDD — ListenButton.tsx

### What to do
Create the ListenButton React component and its test file using TDD.

### Files to create
- NEW: `battlecat/src/components/__tests__/ListenButton.test.tsx`
- NEW: `battlecat/src/components/ListenButton.tsx`

### Detailed instructions

First, ensure test setup file exists for component tests. If `@testing-library/jest-dom` matchers aren't globally available, add a setup file:

**Create `battlecat/src/test-setup.ts` (if needed):**
```ts
import '@testing-library/jest-dom';
```

**Update `battlecat/vitest.config.ts` setupFiles (if needed):**
```ts
setupFiles: ['./src/test-setup.ts'],
```

#### TDD Cycles

**Cycle F1 — Component contract (skip if parent handles null):**
The parent component (`TutorialCard`, `TutorialActions`) only renders `ListenButton` when `audioUrl` is truthy, so this is a documentation test:
```tsx
// Just a note: ListenButton expects audioUrl to be truthy (parent conditionally renders)
```

**Cycle F2 — Icon variant renders speaker icon:**
```tsx
import { render, screen } from '@testing-library/react';
import { ListenButton } from '../ListenButton';

test('renders speaker icon in icon variant', () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="icon" />);
  expect(screen.getByRole('button', { name: /play tutorial audio/i })).toBeInTheDocument();
});
```

**Cycle F3 — Bar variant renders with label text:**
```tsx
test('renders "Listen" text in bar variant', () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="bar" />);
  expect(screen.getByText('Listen')).toBeInTheDocument();
});
```

**Cycle F4 — Click toggles aria-pressed:**
```tsx
import userEvent from '@testing-library/user-event';

test('toggles aria-pressed on click', async () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="bar" />);
  const button = screen.getByRole('button');
  expect(button).toHaveAttribute('aria-pressed', 'false');
  await userEvent.click(button);
  expect(button).toHaveAttribute('aria-pressed', 'true');
});
```

Note: You'll need to mock HTMLMediaElement.play/pause since jsdom doesn't support them:
```ts
beforeAll(() => {
  window.HTMLMediaElement.prototype.play = vi.fn().mockResolvedValue(undefined);
  window.HTMLMediaElement.prototype.pause = vi.fn();
  window.HTMLMediaElement.prototype.load = vi.fn();
});
```

**Cycle F5 — Dispatches custom event on play:**
```tsx
test('dispatches battlecat-audio-play event on play', async () => {
  const handler = vi.fn();
  window.addEventListener('battlecat-audio-play', handler);
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="icon" />);
  await userEvent.click(screen.getByRole('button'));
  expect(handler).toHaveBeenCalled();
  window.removeEventListener('battlecat-audio-play', handler);
});
```

**Cycle F6 — Pauses on battlecat-audio-play from another instance:**
```tsx
test('pauses when another instance dispatches play event', async () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="bar" />);
  const button = screen.getByRole('button');
  await userEvent.click(button); // start playing
  // Simulate another instance playing
  window.dispatchEvent(new CustomEvent('battlecat-audio-play', { detail: document.createElement('audio') }));
  expect(button).toHaveAttribute('aria-pressed', 'false');
});
```

#### Production implementation for ListenButton.tsx

```tsx
"use client";
```

**Props:**
```ts
interface ListenButtonProps {
  audioUrl: string;
  variant: "icon" | "bar";
  tutorialTitle?: string;
  imageUrl?: string;
}
```

**Key implementation details:**
- Use a hidden `<audio>` element with `preload="none"` (NOT `new Audio()` — breaks iOS Safari)
- Call `play()` synchronously in click handler call stack (required for iOS)
- Three states: `idle` | `loading` | `playing`
- On play: dispatch `window.dispatchEvent(new CustomEvent('battlecat-audio-play', { detail: audioRef.current }))`
- Listen for `battlecat-audio-play` events: if `event.detail !== audioRef.current`, pause self
- MediaSession API: set metadata with title, artist "Battlecat AI", artwork if imageUrl provided
- `aria-label`: "Play tutorial audio" when idle/loading, "Pause tutorial audio" when playing
- `aria-pressed`: false when idle/loading, true when playing
- Error handling: on `<audio>` error event, show "Audio unavailable" for 3 seconds
- Loading state: pulse animation CSS between click and `canplay` event
- Cleanup on unmount: pause audio, remove event listeners
- **Icon variant**: `h-5 w-5` speaker SVG, same button styling as bookmark in TutorialCard
- **Bar variant**: same button styling as Bookmark/Complete in TutorialActions (`inline-flex items-center gap-1.5 rounded-lg border px-3 py-2 text-sm font-medium transition-colors`)

### Acceptance criteria
- All component tests pass
- Both icon and bar variants render correctly
- Proper ARIA attributes (aria-label, aria-pressed)
- Single-player behavior via custom events
- MediaSession API integration

---

## Task 5: Pipeline Integration — process-submission.ts

### What to do
Integrate audio generation into the processing pipeline alongside image generation.

### File to modify
- `battlecat/src/lib/process-submission.ts`

### Detailed instructions

**5a. Add import at top of file:**
```ts
import { generateTutorialAudio } from "@/lib/generate-audio";
```

**5b. Capture audio variables in both branches.**

In the merge branch (after line 109, `tutorialId = existing.id;`), add:
```ts
const audioBody = merged.body;
const audioSlug = existing.slug;
```

In the new tutorial branch (after line 149, `tutorialId = created!.id;`), add:
```ts
const audioBody = generated.body;
const audioSlug = tutorialPayload.slug;
```

But since these are in separate `if/else` blocks, you need to declare them before the if/else and assign in each branch:
```ts
let audioBody: string;
let audioSlug: string;

if (existing) {
  // ... existing merge code ...
  audioBody = merged.body;
  audioSlug = existing.slug;
} else {
  // ... existing new tutorial code ...
  audioBody = generated.body;
  audioSlug = tutorialPayload.slug;
}
```

**5c. Replace the image generation block (lines 152-170) with parallel image+audio:**
```ts
// 8. Generate hero image + audio (non-blocking — if either fails, tutorial still publishes)
const pipelineStart = Date.now();
const [imageResult, audioResult] = await Promise.all([
  generateTutorialImage(
    generated.title,
    generated.classification.topics,
    generated.classification.maturity_level,
    generated.summary,
    generated.action_items,
  ).catch((err) => {
    console.error(`[process] Image generation failed (non-fatal):`, err);
    return null;
  }),
  Promise.race([
    generateTutorialAudio(audioBody, audioSlug),
    new Promise<null>(resolve => setTimeout(() => {
      console.log("[audio] Timeout after 20s");
      resolve(null);
    }, 20_000)),
  ]).catch((err) => {
    console.error(`[process] Audio generation failed (non-fatal):`, err);
    return null;
  }),
]);

const mediaUpdate: Record<string, unknown> = {};
if (imageResult) mediaUpdate.image_url = imageResult;
if (audioResult) mediaUpdate.audio_url = audioResult;
if (Object.keys(mediaUpdate).length > 0) {
  await supabase.from("tutorials").update(mediaUpdate).eq("id", tutorialId);
}
if (imageResult) console.log(`[process] Generated hero image for ${tutorialId}`);
if (audioResult) console.log(`[process] Generated audio for ${tutorialId}`);
console.log(`[process] Media generation completed in ${Date.now() - pipelineStart}ms`);
```

**5d. Note:** The `audioBody` and `audioSlug` variables need to be accessible in both branches. The `generated` object is available in both branches since it's created before the merge check. For the merge branch, `merged.body` is the updated body. For new tutorials, `generated.body` is the body.

### Acceptance criteria
- `npx tsc --noEmit` passes
- Audio generation runs in parallel with image generation
- 20-second timeout protects against slow TTS
- Non-blocking: if audio fails, tutorial still publishes
- Both merge and new-tutorial paths produce audio

---

## Task 6: Wire ListenButton into UI Components

### What to do
Add ListenButton to TutorialCard (icon variant) and TutorialActions (bar variant), and pass audioUrl from the detail page.

### Files to modify
- `battlecat/src/components/TutorialCard.tsx`
- `battlecat/src/components/TutorialActions.tsx`
- `battlecat/src/app/tutorials/[slug]/page.tsx`

### Detailed instructions

**6a. `battlecat/src/components/TutorialCard.tsx`:**

Add import at top:
```tsx
import { ListenButton } from "./ListenButton";
```

Replace the bookmark button section (lines 140-164). Wrap the existing bookmark button and a conditional ListenButton in a flex column:
```tsx
{showBookmark && onToggleBookmark && (
  <div className="flex flex-col items-center gap-1">
    <button
      onClick={(e) => {
        e.preventDefault();
        e.stopPropagation();
        onToggleBookmark(tutorial.id);
      }}
      className="shrink-0 p-1 text-bc-text-secondary hover:text-bc-secondary transition-colors"
      aria-label={isBookmarked ? "Remove bookmark" : "Add bookmark"}
    >
      <svg
        className="h-5 w-5"
        fill={isBookmarked ? "currentColor" : "none"}
        viewBox="0 0 24 24"
        stroke="currentColor"
        strokeWidth={2}
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"
        />
      </svg>
    </button>
    {tutorial.audio_url && (
      <div onClick={(e) => { e.preventDefault(); e.stopPropagation(); }}>
        <ListenButton
          audioUrl={tutorial.audio_url}
          variant="icon"
          tutorialTitle={tutorial.title}
          imageUrl={tutorial.image_url ?? undefined}
        />
      </div>
    )}
  </div>
)}
```

Note the `onClick` wrapper on the ListenButton div to prevent the Link from navigating when clicking the listen button.

**6b. `battlecat/src/components/TutorialActions.tsx`:**

Add import at top:
```tsx
import { ListenButton } from "./ListenButton";
```

Add `audioUrl` to props interface:
```ts
interface TutorialActionsProps {
  tutorialId: string;
  tutorialTitle: string;
  tutorialSlug: string;
  isStale?: boolean;
  audioUrl?: string | null;
}
```

Update the destructuring to include `audioUrl`:
```ts
export function TutorialActions({
  tutorialId,
  tutorialTitle,
  tutorialSlug,
  isStale = false,
  audioUrl,
}: TutorialActionsProps) {
```

Add ListenButton between Bookmark and Mark Complete buttons (after the Bookmark button's closing `</button>`, before the Mark Complete `<button>`):
```tsx
{/* Listen */}
{audioUrl && (
  <ListenButton audioUrl={audioUrl} variant="bar" tutorialTitle={tutorialTitle} />
)}
```

**6c. `battlecat/src/app/tutorials/[slug]/page.tsx`:**

Add `audioUrl` prop to TutorialActions (line 130-135):
```tsx
<TutorialActions
  tutorialId={tutorial.id}
  tutorialTitle={tutorial.title}
  tutorialSlug={tutorial.slug}
  isStale={tutorial.is_stale}
  audioUrl={tutorial.audio_url}
/>
```

### Acceptance criteria
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- ListenButton icon appears on TutorialCard when `audio_url` is present
- ListenButton bar appears on detail page when `audio_url` is present
- No ListenButton when `audio_url` is null
- Clicking ListenButton on TutorialCard doesn't navigate to tutorial

---

## Task 7: Final Verification

### What to do
Run all verification commands to confirm the entire implementation is correct.

### Commands
```bash
cd /Users/developer-sandbox/Desktop/Development/miki/playground/battlecat

# 1. All tests pass
npm test

# 2. No type errors
npx tsc --noEmit

# 3. Successful production build
npm run build

# 4. No lint errors
npm run lint
```

### TDD Checklist
- [ ] Every new function has a test
- [ ] Each test failed for expected reason before implementation
- [ ] Wrote minimal code to pass each test
- [ ] All tests pass
- [ ] Output pristine (no errors, warnings)
- [ ] Mocks only where unavoidable (Deepgram SDK, Supabase client)
- [ ] Edge cases covered (empty input, short text, missing env vars, long sentences)

### Acceptance criteria
- All 4 commands succeed with zero errors
- All tests GREEN
- Build output clean

---

## Files Summary

**New files (7):**
- `battlecat/vitest.config.ts`
- `battlecat/src/test-setup.ts` (if needed for jest-dom matchers)
- `battlecat/src/lib/generate-audio.ts`
- `battlecat/src/lib/__tests__/generate-audio.test.ts`
- `battlecat/src/components/ListenButton.tsx`
- `battlecat/src/components/__tests__/ListenButton.test.tsx`
- `battlecat/src/db/migrations/001_add_audio_url.sql`

**Modified files (7):**
- `battlecat/package.json` — vitest + testing-library devDeps, test script
- `battlecat/src/types/index.ts` — add `audio_url: string | null`
- `battlecat/src/data/seed-tutorials.ts` — add `audio_url: null` to all 10 seeds
- `battlecat/src/db/schema.sql` — add `audio_url text` column
- `battlecat/.env.example` — add `AUDIO_ENABLED`, `TOGETHER_API_KEY`
- `battlecat/src/lib/process-submission.ts` — parallel image+audio, timeout
- `battlecat/src/components/TutorialCard.tsx` — ListenButton icon variant
- `battlecat/src/components/TutorialActions.tsx` — ListenButton bar variant + audioUrl prop
- `battlecat/src/app/tutorials/[slug]/page.tsx` — pass audioUrl to TutorialActions
