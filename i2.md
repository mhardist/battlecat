# Listen to Tutorial — Merged Execution Plan (Plan B + Plan C improvements)

> **Base:** Plan B (`i1.md`) — sequential subagent-driven development with triple review
> **Enhancements from Plan C (`battlecat/i.md`):** types test with TDD, `stripMp3Headers()` as separate tested function, `/clear` between phases, dependency graph, smoke test, `imageUrl` prop passthrough, code review between phases

---

## One-Shot Execution Prompt

Open a **new terminal** in `battlecat/` and paste:

```
Use the subagent-driven-development skill to execute the plan in /Users/developer-sandbox/Desktop/Development/miki/playground/i2.md

Branch: bkirsch-listen-build (already checked out)
Working directory: /Users/developer-sandbox/Desktop/Development/miki/playground/battlecat

Context management:
- Use /clear between major task groups (after Task 2, after Task 4, after Task 6)
- Dispatch a fresh implementer subagent per task with the full task text
- After implementation, dispatch a spec reviewer subagent
- After spec approval, dispatch a code quality reviewer subagent
- Mark task complete only when both reviews pass
- Commit after each task passes both reviews

Execution order:
- Tasks 1-2: Sequential (foundation — everything depends on this)
- /clear
- Tasks 3-4: Sequential in ONE subagent (shared files: generate-audio.ts + test file)
- Task 5: Sequential (depends on Tasks 3-4 output)
- /clear
- Tasks 6-7: Can run as PARALLEL subagents (Task 6 = ListenButton component, Task 7 = pipeline integration — independent files)
- /clear
- Task 8: Sequential (wires everything together)
- Task 9: Final verification

TDD is mandatory: write failing test FIRST → run RED → implement → run GREEN → refactor → commit.
Do NOT modify tests to make them pass — fix the implementation instead.
Use the superpowers:verification-before-completion skill before claiming done.
```

---

## Context Management Strategy (from Plan C)

- **Main orchestrator stays lean** — only dispatches tasks and reviews results
- **Fresh subagent per task** — each gets a clean 200k context window
- **`/clear` between task groups** to reset orchestrator context
- **Subagents handle the heavy reading/writing**; orchestrator just coordinates
- **File contention strategy:** Tasks 3+4 share `generate-audio.ts` + its test file — run sequentially in ONE subagent

---

## Execution Order & Dependencies

```
Tasks 1-2 (sequential — foundation):
  Task 1: Vitest setup + smoke test
  Task 2: Types + seed + schema + migration (with TDD)
  /clear

Tasks 3-4-5 (sequential — shared files + dependency):
  Task 3: stripMarkdownToScript()           [TDD]
  Task 4: chunkText() + stripMp3Headers()   [TDD]
  Task 5: generateTutorialAudio()           [TDD]
  /clear

Tasks 6-7 (PARALLEL — independent files):
  Task 6: ListenButton component            [TDD]
  Task 7: Pipeline integration (process-submission.ts)
  /clear

Task 8 (sequential — depends on Tasks 6+7):
  Wire ListenButton into UI components

Task 9: Final verification
```

**Total tasks:** 9
**Total commits:** ~9

---

## Task 1: Test Infrastructure Setup

### What to do
Install Vitest and testing libraries. Create config. Verify with smoke test.

### Files to modify
- `battlecat/package.json`
- NEW: `battlecat/vitest.config.ts`
- NEW: `battlecat/src/lib/__tests__/smoke.test.ts` (temporary — delete after verification)

### Detailed instructions

**1a. Install devDependencies:**
```bash
npm install --save-dev vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
```

**1b. Add scripts to `battlecat/package.json`:**
```json
"test": "vitest run",
"test:watch": "vitest"
```

**1c. Create `battlecat/vitest.config.ts`:**
```ts
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: [],
  },
});
```

**1d. Write smoke test** `battlecat/src/lib/__tests__/smoke.test.ts` (from Plan C):
```ts
import { describe, it, expect } from 'vitest';

describe('vitest setup', () => {
  it('runs a basic test', () => {
    expect(1 + 1).toBe(2);
  });

  it('resolves @/ alias', async () => {
    const types = await import('@/types');
    expect(types).toBeDefined();
  });
});
```

**1e. Run smoke test:**
```bash
npx vitest run
```
Expected: 2 tests pass.

**1f. Delete smoke test, then commit:**
```bash
rm battlecat/src/lib/__tests__/smoke.test.ts
git add vitest.config.ts package.json package-lock.json
git commit -m "feat: add vitest test runner with path alias configuration"
```

### Acceptance criteria
- `npx vitest --version` succeeds
- Smoke test passes (2/2), then is deleted before commit
- `npm test` runs without config errors

---

## Task 2: Foundation — Config/Types/Schema (with TDD from Plan C)

### What to do
Add `audio_url` field across the codebase. **Unlike Plan B original, this task uses TDD** — write a failing test for the type + seed data first (from Plan C's Task 1.2).

### Files to modify
- NEW: `battlecat/src/lib/__tests__/types.test.ts`
- `battlecat/src/types/index.ts`
- `battlecat/src/data/seed-tutorials.ts`
- `battlecat/src/db/schema.sql`
- NEW: `battlecat/src/db/migrations/001_add_audio_url.sql`
- `battlecat/.env.example`

### Detailed instructions

**2a. Write failing test** `battlecat/src/lib/__tests__/types.test.ts` (from Plan C):
```ts
import { describe, it, expect } from 'vitest';
import type { Tutorial } from '@/types';
import { SEED_TUTORIALS } from '@/data/seed-tutorials';

describe('Tutorial type includes audio_url', () => {
  it('accepts audio_url as null', () => {
    const partial: Pick<Tutorial, 'audio_url'> = { audio_url: null };
    expect(partial.audio_url).toBeNull();
  });

  it('accepts audio_url as string', () => {
    const partial: Pick<Tutorial, 'audio_url'> = { audio_url: 'https://example.com/a.mp3' };
    expect(partial.audio_url).toBe('https://example.com/a.mp3');
  });
});

describe('seed tutorials have audio_url', () => {
  it('every seed tutorial has audio_url: null', () => {
    for (const t of SEED_TUTORIALS) {
      expect(t).toHaveProperty('audio_url');
      expect(t.audio_url).toBeNull();
    }
  });
});
```

**2b. Run test (RED):**
```bash
npx vitest run src/lib/__tests__/types.test.ts
```
Expected: TypeScript error — `audio_url` does not exist on Tutorial.

**2c. `battlecat/src/types/index.ts` — Add to Tutorial interface after line 63 (`image_url: string | null;`):**
```ts
audio_url: string | null;
```

**2d. `battlecat/src/data/seed-tutorials.ts` — Add `audio_url: null` to every seed tutorial object.**
There are 10 seed tutorials. Each one needs `audio_url: null` added after the `image_url` field:
```ts
image_url: null,
audio_url: null,
```
All 10 tutorials: seed-01 through seed-10.

**2e. `battlecat/src/db/schema.sql` — Add after `image_url text,` (line 32):**
```sql
audio_url text,
```

**2f. Create `battlecat/src/db/migrations/001_add_audio_url.sql`:**
```sql
-- Migration 001: Add audio_url column to tutorials table
-- Run on Supabase SQL editor after deploying code.
ALTER TABLE tutorials ADD COLUMN IF NOT EXISTS audio_url text;
```

**2g. `battlecat/.env.example` — Add at the end:**
```
# Audio generation (set to "true" to enable)
AUDIO_ENABLED=false
TOGETHER_API_KEY=your-together-key
```

**2h. Run test (GREEN):**
```bash
npx vitest run src/lib/__tests__/types.test.ts
```

**2i. Verify full build:**
```bash
npx tsc --noEmit
```

**2j. Commit:**
```bash
git add src/types/index.ts src/data/seed-tutorials.ts src/db/schema.sql src/db/migrations/ .env.example src/lib/__tests__/types.test.ts
git commit -m "feat: add audio_url to Tutorial type, seed data, schema, and migration"
```

### Acceptance criteria
- Types test passes (GREEN) after implementation
- `npx tsc --noEmit` passes with zero errors
- All 10 seed tutorials have `audio_url: null`
- Tutorial interface includes `audio_url: string | null`

---

## `/clear` — Reset orchestrator context before backend TDD

---

## Task 3: Backend TDD — `stripMarkdownToScript()`

### What to do
Create `generate-audio.ts` and its test file. First function: `stripMarkdownToScript`.

### Files to create
- NEW: `battlecat/src/lib/__tests__/generate-audio.test.ts`
- NEW: `battlecat/src/lib/generate-audio.ts`

### Detailed instructions

Follow these TDD cycles exactly. For each cycle: write the test FIRST, verify it fails, then write minimal production code to make it pass.

**Cycle 1 — Headers:**
```ts
test('removes markdown headers', () => {
  expect(stripMarkdownToScript('## Hello World')).toBe('Hello World');
  expect(stripMarkdownToScript('### Sub heading')).toBe('Sub heading');
});
```
Create `generate-audio.ts`, export `stripMarkdownToScript`. Minimal header-stripping regex.

**Cycle 2 — Code blocks:**
```ts
test('removes fenced code blocks', () => {
  const input = 'Before\n```js\nconst x = 1;\n```\nAfter';
  expect(stripMarkdownToScript(input)).toBe('Before\nAfter');
});

test('removes inline code', () => {
  expect(stripMarkdownToScript('Use `npm install` to install')).toBe('Use npm install to install');
});
```

**Cycle 3 — Links, images, URLs:**
```ts
test('converts links to text only', () => {
  expect(stripMarkdownToScript('[Click here](https://example.com)')).toBe('Click here');
});

test('removes images', () => {
  expect(stripMarkdownToScript('![alt text](image.png)')).toBe('');
});

test('removes bare URLs', () => {
  expect(stripMarkdownToScript('Visit https://example.com/path for more'))
    .toBe('Visit for more');
});
```

**Cycle 4 — Bold, italic, blockquotes, lists, rules:**
```ts
test('removes bold and italic markers', () => {
  expect(stripMarkdownToScript('This is **bold** and *italic*')).toBe('This is bold and italic');
});

test('removes blockquote markers', () => {
  expect(stripMarkdownToScript('> This is a quote')).toBe('This is a quote');
});

test('removes list markers', () => {
  expect(stripMarkdownToScript('- Item one\n* Item two\n1. Item three'))
    .toBe('Item one\nItem two\nItem three');
});

test('removes horizontal rules', () => {
  expect(stripMarkdownToScript('Above\n---\nBelow')).toBe('Above\nBelow');
});
```

**Cycle 5 — HTML entities, tags, tables:**
```ts
test('decodes HTML entities', () => {
  expect(stripMarkdownToScript('Tom &amp; Jerry &lt;3')).toBe('Tom & Jerry <3');
});

test('strips inline HTML tags', () => {
  expect(stripMarkdownToScript('Hello <br> world <strong>bold</strong>'))
    .toBe('Hello world bold');
});

test('removes markdown tables entirely', () => {
  const table = '| Col1 | Col2 |\n|------|------|\n| a | b |';
  expect(stripMarkdownToScript(table).trim()).toBe('');
});
```

**Cycle 6 — Whitespace normalization:**
```ts
test('collapses multiple newlines to single newline', () => {
  expect(stripMarkdownToScript('Line 1\n\n\n\nLine 2')).toBe('Line 1\nLine 2');
});
```

**Cycle 7 — Real tutorial body regression:**
```ts
test('processes a real seed tutorial body correctly', () => {
  const body = `## Getting Started with AI\n\nAI is **transforming** everything...`;
  const result = stripMarkdownToScript(body);
  expect(result).not.toContain('##');
  expect(result).not.toContain('**');
  expect(result).toContain('Getting Started with AI');
  expect(result).toContain('AI is transforming everything');
});
```

**After Cycle 7: REFACTOR** — Review the accumulated regex pipeline. Ensure ordering is correct (fenced blocks before inline code, images before links). Clean up duplication.

**Commit:** `feat: add stripMarkdownToScript() with TDD tests`

### Acceptance criteria
- All 7+ tests pass
- Function handles all markdown constructs listed
- Regex ordering is correct

---

## Task 4: Backend TDD — `chunkText()` + `stripMp3Headers()` (from Plan C)

### What to do
Add `chunkText` and `stripMp3Headers` to `generate-audio.ts` with TDD. `stripMp3Headers` is broken out as a separate tested function (Plan C improvement — Plan B originally embedded it in `generateTutorialAudio`).

### Files to modify
- `battlecat/src/lib/__tests__/generate-audio.test.ts` (append tests)
- `battlecat/src/lib/generate-audio.ts` (add functions)

### Detailed instructions

#### Function: `chunkText`

**Cycle 8 — Basic sentence splitting:**
```ts
test('splits text at sentence boundaries under maxChars', () => {
  const text = 'First sentence. Second sentence. Third sentence.';
  const chunks = chunkText(text, 30);
  expect(chunks.length).toBeGreaterThan(1);
  chunks.forEach(chunk => expect(chunk.length).toBeLessThanOrEqual(30));
});

test('keeps sentences together when they fit', () => {
  const text = 'Short. Also short.';
  const chunks = chunkText(text, 1900);
  expect(chunks).toHaveLength(1);
  expect(chunks[0]).toBe('Short. Also short.');
});
```

**Cycle 9 — Long sentence fallback:**
```ts
test('splits single sentence exceeding maxChars at word boundary', () => {
  const longSentence = 'word '.repeat(400); // ~2000 chars
  const chunks = chunkText(longSentence.trim(), 1900);
  expect(chunks.length).toBeGreaterThan(1);
  chunks.forEach(chunk => expect(chunk.length).toBeLessThanOrEqual(1900));
});
```

**Cycle 10 — Edge cases:**
```ts
test('returns empty array for empty string', () => {
  expect(chunkText('')).toEqual([]);
});

test('returns empty array for very short text (under 50 chars)', () => {
  expect(chunkText('Hi')).toEqual([]);
});
```

**Commit:** `feat: add chunkText() sentence-boundary splitter with TDD tests`

#### Function: `stripMp3Headers` (from Plan C — Task 2.3)

**Cycle 11 — Buffer without ID3 header:**
```ts
test('returns buffer unchanged when no ID3 header present', () => {
  const buf = Buffer.from([0xFF, 0xFB, 0x90, 0x00, 0x01, 0x02]);
  const result = stripMp3Headers(buf);
  expect(result).toEqual(buf);
});
```

**Cycle 12 — Buffer with ID3v2 header:**
```ts
test('strips ID3v2 header and preserves audio data', () => {
  // ID3v2 header: "ID3" + version (2 bytes) + flags (1 byte) + size (4 bytes syncsafe)
  // Size = 10 in syncsafe = [0x00, 0x00, 0x00, 0x0A]
  // Total header = 10 (fixed) + 10 (size) = 20 bytes
  const header = Buffer.from([
    0x49, 0x44, 0x33, // "ID3"
    0x04, 0x00,       // version 2.4.0
    0x00,             // flags
    0x00, 0x00, 0x00, 0x0A, // size = 10 (syncsafe)
  ]);
  const padding = Buffer.alloc(10); // 10 bytes of padding (matching size)
  const audioData = Buffer.from([0xFF, 0xFB, 0x90, 0x00]);
  const fullBuffer = Buffer.concat([header, padding, audioData]);

  const result = stripMp3Headers(fullBuffer);
  expect(result).toEqual(audioData);
});
```

**Cycle 13 — Edge cases:**
```ts
test('returns empty buffer for empty input', () => {
  const result = stripMp3Headers(Buffer.alloc(0));
  expect(result.length).toBe(0);
});

test('returns buffer unchanged when too small for ID3', () => {
  const buf = Buffer.from([0x49, 0x44]); // Only "ID" — not enough
  const result = stripMp3Headers(buf);
  expect(result).toEqual(buf);
});
```

**Implementation — ID3v2 header detection and stripping:**
```
If buffer.length >= 10 AND bytes 0-2 == "ID3" (0x49, 0x44, 0x33):
  Parse syncsafe integer size from bytes 6-9 (7 bits per byte)
  headerSize = 10 + size
  Return buffer.subarray(headerSize)
Else: return buffer unchanged
```

**Commit:** `feat: add stripMp3Headers() utility with TDD tests`

### Acceptance criteria
- All chunkText tests pass
- All stripMp3Headers tests pass
- stripMp3Headers correctly handles ID3v2 syncsafe integer parsing
- Edge cases covered (empty input, short text, buffers without headers)

---

## Task 5: Backend TDD — `generateTutorialAudio()`

### What to do
Add the main `generateTutorialAudio` function that orchestrates strip -> chunk -> TTS -> MP3 concat -> upload.

### Files to modify
- `battlecat/src/lib/__tests__/generate-audio.test.ts` (append tests)
- `battlecat/src/lib/generate-audio.ts` (add function)

### Detailed instructions

**Cycle 14 — Kill switch:**
```ts
test('returns null when AUDIO_ENABLED is not "true"', async () => {
  process.env.AUDIO_ENABLED = 'false';
  const result = await generateTutorialAudio('Some body text', 'test-slug');
  expect(result).toBeNull();
});
```

**Cycle 15 — Missing API key:**
```ts
test('returns null when DEEPGRAM_API_KEY is not set', async () => {
  process.env.AUDIO_ENABLED = 'true';
  delete process.env.DEEPGRAM_API_KEY;
  const result = await generateTutorialAudio('Some body text', 'test-slug');
  expect(result).toBeNull();
});
```

**Cycle 16 — Short text skip:**
```ts
test('returns null when sanitized text is under 50 chars', async () => {
  process.env.AUDIO_ENABLED = 'true';
  process.env.DEEPGRAM_API_KEY = 'test-key';
  const result = await generateTutorialAudio('# Hi', 'test-slug');
  expect(result).toBeNull();
});
```

**Cycle 17 — Full pipeline with mocks:**
```ts
// Mock @deepgram/sdk and @/lib/supabase at top of test file
vi.mock('@deepgram/sdk', () => ({
  createClient: () => ({
    speak: {
      request: vi.fn().mockResolvedValue({
        getStream: () => readableStreamFromBuffer(Buffer.from('fake-mp3')),
      }),
    },
  }),
}));

vi.mock('@/lib/supabase', () => ({
  createServerClient: () => ({
    storage: {
      from: () => ({
        upload: vi.fn().mockResolvedValue({ error: null }),
        getPublicUrl: () => ({ data: { publicUrl: 'https://example.com/audio.mp3' } }),
      }),
    },
  }),
}));

test('generates audio and returns URL on success', async () => {
  process.env.AUDIO_ENABLED = 'true';
  process.env.DEEPGRAM_API_KEY = 'test-key';
  const body = 'A '.repeat(100) + 'long tutorial body with enough content to process.';
  const result = await generateTutorialAudio(body, 'test-slug');
  expect(result).toBe('https://example.com/audio.mp3');
});
```

#### Production code for `generateTutorialAudio`

Follow `generate-image.ts` pattern:
- Never throw — try/catch returns null
- `[audio]` prefix for all console.log/error
- Dynamic import for supabase: `const { createServerClient } = await import("@/lib/supabase")`
- Deepgram TTS: `createClient(apiKey)`, then `client.speak.request({ text }, { model: "aura-2-athena-en", encoding: "mp3", sample_rate: 24000 })`
- For multi-chunk audio: call `stripMp3Headers()` on chunks 2+ before concatenation
- Concatenate all chunks into single Buffer
- Upload to `audio` bucket: `tutorials/${slug}-${Date.now()}.mp3`
- Return public URL
- Success log: `[audio] Generated for {slug}: {chunks} chunks, {bytes} bytes, {ms}ms`

**Commit:** `feat: add generateTutorialAudio() with Deepgram TTS and Supabase upload`

### Acceptance criteria
- All tests pass with `npm test`
- Every exported function has test coverage
- Mocks only where unavoidable (Deepgram SDK, Supabase client)
- Output pristine (no warnings/errors)

---

## `/clear` — Reset orchestrator context before frontend + pipeline work

---

## Task 6: Frontend TDD — ListenButton.tsx (CAN RUN PARALLEL with Task 7)

### What to do
Create the ListenButton React component and its test file using TDD.

### Files to create
- NEW: `battlecat/src/components/__tests__/ListenButton.test.tsx`
- NEW: `battlecat/src/components/ListenButton.tsx`
- NEW: `battlecat/src/test-setup.ts` (if needed for jest-dom matchers)

### Detailed instructions

First, ensure test setup file exists for component tests:

**Create `battlecat/src/test-setup.ts`:**
```ts
import '@testing-library/jest-dom';
```

**Update `battlecat/vitest.config.ts` setupFiles:**
```ts
setupFiles: ['./src/test-setup.ts'],
```

**Mock HTMLMediaElement** (required — jsdom doesn't support audio):
```ts
beforeAll(() => {
  window.HTMLMediaElement.prototype.play = vi.fn().mockResolvedValue(undefined);
  window.HTMLMediaElement.prototype.pause = vi.fn();
  window.HTMLMediaElement.prototype.load = vi.fn();
});
```

#### TDD Cycles

**Cycle F1 — Icon variant renders speaker icon:**
```tsx
import { render, screen } from '@testing-library/react';
import { ListenButton } from '../ListenButton';

test('renders speaker icon in icon variant', () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="icon" />);
  expect(screen.getByRole('button', { name: /play tutorial audio/i })).toBeInTheDocument();
});
```

**Cycle F2 — Bar variant renders with label text:**
```tsx
test('renders "Listen" text in bar variant', () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="bar" />);
  expect(screen.getByText('Listen')).toBeInTheDocument();
});
```

**Cycle F3 — Click toggles aria-pressed:**
```tsx
import userEvent from '@testing-library/user-event';

test('toggles aria-pressed on click', async () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="bar" />);
  const button = screen.getByRole('button');
  expect(button).toHaveAttribute('aria-pressed', 'false');
  await userEvent.click(button);
  expect(button).toHaveAttribute('aria-pressed', 'true');
});
```

**Cycle F4 — Dispatches custom event on play:**
```tsx
test('dispatches battlecat-audio-play event on play', async () => {
  const handler = vi.fn();
  window.addEventListener('battlecat-audio-play', handler);
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="icon" />);
  await userEvent.click(screen.getByRole('button'));
  expect(handler).toHaveBeenCalled();
  window.removeEventListener('battlecat-audio-play', handler);
});
```

**Cycle F5 — Pauses on battlecat-audio-play from another instance:**
```tsx
test('pauses when another instance dispatches play event', async () => {
  render(<ListenButton audioUrl="https://example.com/audio.mp3" variant="bar" />);
  const button = screen.getByRole('button');
  await userEvent.click(button); // start playing
  // Simulate another instance playing
  window.dispatchEvent(new CustomEvent('battlecat-audio-play', { detail: document.createElement('audio') }));
  expect(button).toHaveAttribute('aria-pressed', 'false');
});
```

#### Production implementation for ListenButton.tsx

```tsx
"use client";
```

**Props:**
```ts
interface ListenButtonProps {
  audioUrl: string;
  variant: "icon" | "bar";
  tutorialTitle?: string;
  imageUrl?: string | null;
}
```

**Key implementation details:**
- Use a hidden `<audio>` element with `preload="none"` (NOT `new Audio()` — breaks iOS Safari)
- Call `play()` synchronously in click handler call stack (required for iOS)
- Three states: `idle` | `loading` | `playing`
- On play: dispatch `window.dispatchEvent(new CustomEvent('battlecat-audio-play', { detail: audioRef.current }))`
- Listen for `battlecat-audio-play` events: if `event.detail !== audioRef.current`, pause self
- MediaSession API: set metadata with title, artist "Battlecat AI", artwork if imageUrl provided
- MediaSession action handlers: `play`, `pause`, `stop`
- `aria-label`: "Play tutorial audio" when idle/loading, "Pause tutorial audio" when playing
- `aria-pressed`: false when idle/loading, true when playing
- Error handling: on `<audio>` error event, show "Audio unavailable" for 3 seconds
- Loading state: `animate-pulse` CSS between click and `canplay` event
- Cleanup on unmount: pause audio, remove event listeners
- **Icon variant**: `h-5 w-5` speaker SVG, same button styling as bookmark in TutorialCard
- **Bar variant**: `inline-flex items-center gap-1.5 rounded-lg border px-3 py-2 text-sm font-medium transition-colors` — matches Bookmark/Complete styling

**Commit:** `feat: add ListenButton component with icon/bar variants, single-player, MediaSession, a11y`

### Acceptance criteria
- All component tests pass
- Both icon and bar variants render correctly
- Proper ARIA attributes (aria-label, aria-pressed)
- Single-player behavior via custom events
- MediaSession API integration

---

## Task 7: Pipeline Integration — process-submission.ts (CAN RUN PARALLEL with Task 6)

### What to do
Integrate audio generation into the processing pipeline alongside image generation.

### File to modify
- `battlecat/src/lib/process-submission.ts`

### Detailed instructions

**7a. Add import at top of file:**
```ts
import { generateTutorialAudio } from "@/lib/generate-audio";
```

**7b. Add pipeline timer** (inside try block, early):
```ts
const pipelineStart = Date.now();
```

**7c. Hoist merged result variable** (before the `if (existing)` block — from Plan C):
```ts
let mergedResult: { body: string; summary: string; action_items: string[] } | null = null;
```
Then inside the `if (existing)` block, set `mergedResult = merged;` after the `mergeTutorial()` call.

**7d. Replace the image generation block (lines 152-170) with parallel image+audio:**
```ts
// 8. Generate hero image + audio in parallel (non-fatal)
let imageUrl: string | null = null;
let audioUrl: string | null = null;

try {
  const imagePromise = generateTutorialImage(
    generated.title,
    generated.classification.topics,
    generated.classification.maturity_level,
    generated.summary,
    generated.action_items,
  );

  // Use merged body for audio when merging, generated body for new tutorials
  const audioBody = mergedResult?.body ?? generated.body;
  const audioSlug = existing ? existing.slug : generated.slug;

  const audioPromise = Promise.race([
    generateTutorialAudio(audioBody, audioSlug),
    new Promise<null>((resolve) => setTimeout(() => {
      console.log('[audio] Timeout after 20s');
      resolve(null);
    }, 20_000)),
  ]);

  [imageUrl, audioUrl] = await Promise.all([imagePromise, audioPromise]);

  const updates: Record<string, unknown> = {};
  if (imageUrl) updates.image_url = imageUrl;
  if (audioUrl) updates.audio_url = audioUrl;
  if (Object.keys(updates).length > 0) {
    await supabase.from("tutorials").update(updates).eq("id", tutorialId);
  }
  if (imageUrl) console.log(`[process] Generated hero image for ${tutorialId}`);
  if (audioUrl) console.log(`[process] Generated audio for ${tutorialId}`);
} catch (mediaErr) {
  console.error(`[process] Media generation failed (non-fatal):`, mediaErr);
}
```

**7e. Add elapsed time log** (before the return):
```ts
const elapsed = Date.now() - pipelineStart;
console.log(`[process] processSubmission completed in ${elapsed}ms`);
```

**Commit:** `feat: integrate audio generation into pipeline with parallel execution and 20s timeout`

### Acceptance criteria
- `npx tsc --noEmit` passes
- Audio generation runs in parallel with image generation
- 20-second timeout protects against slow TTS
- Non-blocking: if audio fails, tutorial still publishes
- Both merge and new-tutorial paths produce audio

---

## `/clear` — Reset orchestrator context before UI wiring

---

## Task 8: Wire ListenButton into UI Components

### What to do
Add ListenButton to TutorialCard (icon variant), TutorialActions (bar variant), and pass props from the detail page. Also pass `imageUrl` (from Plan C).

### Files to modify
- `battlecat/src/components/TutorialCard.tsx`
- `battlecat/src/components/TutorialActions.tsx`
- `battlecat/src/app/tutorials/[slug]/page.tsx`

### Detailed instructions

**8a. `battlecat/src/components/TutorialCard.tsx`:**

Add import:
```tsx
import { ListenButton } from "./ListenButton";
```

Replace the bookmark button section (lines 140-164). Wrap existing bookmark + conditional ListenButton in a flex column:
```tsx
{showBookmark && onToggleBookmark && (
  <div className="flex flex-col items-center gap-1">
    <button
      onClick={(e) => {
        e.preventDefault();
        e.stopPropagation();
        onToggleBookmark(tutorial.id);
      }}
      className="shrink-0 p-1 text-bc-text-secondary hover:text-bc-secondary transition-colors"
      aria-label={isBookmarked ? "Remove bookmark" : "Add bookmark"}
    >
      <svg
        className="h-5 w-5"
        fill={isBookmarked ? "currentColor" : "none"}
        viewBox="0 0 24 24"
        stroke="currentColor"
        strokeWidth={2}
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"
        />
      </svg>
    </button>
    {tutorial.audio_url && (
      <div onClick={(e) => { e.preventDefault(); e.stopPropagation(); }}>
        <ListenButton
          audioUrl={tutorial.audio_url}
          variant="icon"
          tutorialTitle={tutorial.title}
          imageUrl={tutorial.image_url ?? undefined}
        />
      </div>
    )}
  </div>
)}
```

Note: The `onClick` wrapper on ListenButton div prevents Link navigation when clicking listen.

**8b. `battlecat/src/components/TutorialActions.tsx`:**

Add import:
```tsx
import { ListenButton } from "./ListenButton";
```

Add `audioUrl` and `imageUrl` to props interface (from Plan C):
```ts
interface TutorialActionsProps {
  tutorialId: string;
  tutorialTitle: string;
  tutorialSlug: string;
  isStale?: boolean;
  audioUrl?: string | null;
  imageUrl?: string | null;
}
```

Update destructuring to include `audioUrl` and `imageUrl`.

Add ListenButton between Bookmark and Mark Complete buttons:
```tsx
{/* Listen */}
{audioUrl && (
  <ListenButton audioUrl={audioUrl} variant="bar" tutorialTitle={tutorialTitle} imageUrl={imageUrl} />
)}
```

**8c. `battlecat/src/app/tutorials/[slug]/page.tsx`:**

Pass both `audioUrl` and `imageUrl` to TutorialActions (from Plan C):
```tsx
<TutorialActions
  tutorialId={tutorial.id}
  tutorialTitle={tutorial.title}
  tutorialSlug={tutorial.slug}
  isStale={tutorial.is_stale}
  audioUrl={tutorial.audio_url}
  imageUrl={tutorial.image_url}
/>
```

**Commit:** `feat: wire ListenButton into TutorialCard, TutorialActions, and detail page`

### Acceptance criteria
- `npx tsc --noEmit` passes
- `npm run build` succeeds
- ListenButton icon appears on TutorialCard when `audio_url` is present
- ListenButton bar appears on detail page when `audio_url` is present
- No ListenButton when `audio_url` is null
- Clicking ListenButton on TutorialCard doesn't navigate to tutorial

---

## Task 9: Final Verification

### What to do
Run all verification commands to confirm the entire implementation is correct.

### Commands
```bash
cd /Users/developer-sandbox/Desktop/Development/miki/playground/battlecat

# 1. All tests pass
npm test

# 2. No type errors
npx tsc --noEmit

# 3. Successful production build
npm run build

# 4. No lint errors
npm run lint
```

### TDD Checklist
- [ ] Every new function has a test
- [ ] Each test failed for expected reason before implementation
- [ ] Wrote minimal code to pass each test
- [ ] All tests pass
- [ ] Output pristine (no errors, warnings)
- [ ] Mocks only where unavoidable (Deepgram SDK, Supabase client)
- [ ] Edge cases covered (empty input, short text, missing env vars, long sentences, empty buffers)

### Acceptance criteria
- All 4 commands succeed with zero errors
- All tests GREEN
- Build output clean

---

## Files Summary

**New files (8):**
- `battlecat/vitest.config.ts`
- `battlecat/src/test-setup.ts`
- `battlecat/src/lib/generate-audio.ts`
- `battlecat/src/lib/__tests__/generate-audio.test.ts`
- `battlecat/src/lib/__tests__/types.test.ts`
- `battlecat/src/components/ListenButton.tsx`
- `battlecat/src/components/__tests__/ListenButton.test.tsx`
- `battlecat/src/db/migrations/001_add_audio_url.sql`

**Modified files (8):**
- `battlecat/package.json` — vitest + testing-library devDeps, test scripts
- `battlecat/src/types/index.ts` — add `audio_url: string | null`
- `battlecat/src/data/seed-tutorials.ts` — add `audio_url: null` to all 10 seeds
- `battlecat/src/db/schema.sql` — add `audio_url text` column
- `battlecat/.env.example` — add `AUDIO_ENABLED`, `TOGETHER_API_KEY`
- `battlecat/src/lib/process-submission.ts` — parallel image+audio, timeout, timing log
- `battlecat/src/components/TutorialCard.tsx` — ListenButton icon variant
- `battlecat/src/components/TutorialActions.tsx` — ListenButton bar variant + audioUrl/imageUrl props
- `battlecat/src/app/tutorials/[slug]/page.tsx` — pass audioUrl + imageUrl to TutorialActions

---

## Post-Deploy Checklist

1. Run migration on Supabase SQL editor: `ALTER TABLE tutorials ADD COLUMN IF NOT EXISTS audio_url text;`
2. Create `audio` bucket in Supabase Dashboard -> Storage -> New bucket -> Name: `audio`, Public: Yes
3. Set `AUDIO_ENABLED=true` in Vercel environment variables
4. Submit a URL via /submit -> verify `[audio]` log lines in Vercel -> verify Listen button appears
5. Test single-player enforcement across cards on /browse
6. Test iOS Safari playback
7. Test lock screen controls (MediaSession)

---

## Sources

- [Claude Code Docs: Best Practices](https://code.claude.com/docs/en/best-practices)
- [Claude Code Docs: Custom Subagents](https://code.claude.com/docs/en/sub-agents)
- [Anthropic: Claude Code Best Practices](https://www.anthropic.com/engineering/claude-code-best-practices)
- [Zach Wills: Parallelizing with Subagents](https://zachwills.net/how-to-use-claude-code-subagents-to-parallelize-development/)
- [PubNub: Best Practices for Subagents](https://www.pubnub.com/blog/best-practices-for-claude-code-sub-agents/)
- [VentureBeat: Boris Cherny's Workflow](https://venturebeat.com/technology/the-creator-of-claude-code-just-revealed-his-workflow-and-developers-are)
- [Spec Driven Development (2026)](https://medium.com/@universe3523/spec-driven-development-with-claude-code-206bf56955d0)
